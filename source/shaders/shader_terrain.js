var shader_lambert_terrain = {
    vert: [
        "varying vec3 vLightFront;",
        "varying float vWaterDepth;",	

        "#ifndef FLAT_SHADED",
        "   varying vec3 vNormal;",
        "#endif",

        "uniform vec2 uvScale;",
        "uniform float waterLevel;",

        "#ifdef DOUBLE_SIDED",
        "    varying vec3 vLightBack;",
        "#endif",

        THREE.ShaderChunk["common"],
        THREE.ShaderChunk["uv_pars_vertex"],
        THREE.ShaderChunk["uv2_pars_vertex"],
        THREE.ShaderChunk["envmap_pars_vertex"],
        THREE.ShaderChunk["bsdfs"],
        THREE.ShaderChunk["lights_pars"],
        THREE.ShaderChunk["color_pars_vertex"],
        THREE.ShaderChunk["fog_pars_vertex"],
        THREE.ShaderChunk["morphtarget_pars_vertex"],
        THREE.ShaderChunk["skinning_pars_vertex"],
        THREE.ShaderChunk["shadowmap_pars_vertex"],
        THREE.ShaderChunk["logdepthbuf_pars_vertex"],
        THREE.ShaderChunk["clipping_planes_pars_vertex"],
        "void main()",
        "{",
            //THREE.ShaderChunk["uv_vertex"],
        "   #if defined(USE_MAP) || defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(USE_SPECULARMAP) || defined(USE_ALPHAMAP) || defined(USE_EMISSIVEMAP) || defined(USE_ROUGHNESSMAP) || defined(USE_METALNESSMAP)",
        "       vUv = (uvTransform * vec3(uv, 1)).xy;",
        "   #endif",

             // calculate texture coordinate
        "    vUv = uvScale * uv;",

        "    vWaterDepth = waterLevel - position.y;",

            THREE.ShaderChunk["uv2_vertex"],
            THREE.ShaderChunk["color_vertex"],
            THREE.ShaderChunk["beginnormal_vertex"],
            THREE.ShaderChunk["morphnormal_vertex"],
            THREE.ShaderChunk["skinbase_vertex"],
            THREE.ShaderChunk["skinnormal_vertex"],
            THREE.ShaderChunk["defaultnormal_vertex"],
        "   #ifndef FLAT_SHADED",
        "       vNormal = normalize(transformedNormal);",
        "   #endif",
            THREE.ShaderChunk["begin_vertex"],
            THREE.ShaderChunk["morphtarget_vertex"],
            THREE.ShaderChunk["skinning_vertex"],
            THREE.ShaderChunk["project_vertex"],
            THREE.ShaderChunk["logdepthbuf_vertex"],
            THREE.ShaderChunk["clipping_planes_vertex"],
            THREE.ShaderChunk["worldpos_vertex"],
            THREE.ShaderChunk["envmap_vertex"],
            THREE.ShaderChunk["lights_lambert_vertex"],
            THREE.ShaderChunk["shadowmap_vertex"],
            THREE.ShaderChunk["fog_vertex"],
        "}",

    ].join("\n"),

    frag: [
        "uniform vec3 diffuse;",
        "uniform vec3 emissive;",
        "uniform float opacity;",

        "varying vec3 vLightFront;",
        "varying float vWaterDepth;",	

        "#ifndef FLAT_SHADED",
        "   varying vec3 vNormal;",
        "#endif",

        // textures in
        "uniform sampler2D bedTexture;",
        "uniform sampler2D shoreTexture;",
        "uniform sampler2D bedNormal;",
        "uniform sampler2D shoreNormal;",

        "#ifdef DOUBLE_SIDED",
        "   varying vec3 vLightBack;",
        "#endif",

        THREE.ShaderChunk["common"],
        THREE.ShaderChunk["packing"],
        THREE.ShaderChunk["dithering_pars_fragment"],
        THREE.ShaderChunk["color_pars_fragment"],
        THREE.ShaderChunk["uv_pars_fragment"],
        THREE.ShaderChunk["uv2_pars_fragment"],
        THREE.ShaderChunk["map_pars_fragment"],
        THREE.ShaderChunk["alphamap_pars_fragment"],
        THREE.ShaderChunk["aomap_pars_fragment"],
        THREE.ShaderChunk["lightmap_pars_fragment"],
        THREE.ShaderChunk["emissivemap_pars_fragment"],
        THREE.ShaderChunk["envmap_pars_fragment"],
        THREE.ShaderChunk["bsdfs"],
        THREE.ShaderChunk["lights_pars"],
        THREE.ShaderChunk["fog_pars_fragment"],
        THREE.ShaderChunk["shadowmap_pars_fragment"],
        THREE.ShaderChunk["shadowmask_pars_fragment"],
        THREE.ShaderChunk["normalmap_pars_fragment"],
        THREE.ShaderChunk["specularmap_pars_fragment"],
        THREE.ShaderChunk["logdepthbuf_pars_fragment"],
        THREE.ShaderChunk["clipping_planes_pars_fragment"],
        "void main()",
        "{",
            THREE.ShaderChunk["clipping_planes_fragment"],

        "   vec4 diffuseColor = vec4(diffuse, opacity);",
        "   ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));",
        "   vec3 totalEmissiveRadiance = emissive;",
            THREE.ShaderChunk["logdepthbuf_fragment"],

            // Overriding colouring behaviours

            //THREE.ShaderChunk["map_fragment"],
        "   #ifdef USE_MAP",
        "       float isAboveWater = clamp(-vWaterDepth, 0.0, 1.0);",

        "       vec4 texelColor = mix(texture2D(bedTexture, vUv), texture2D(shoreTexture, vUv), isAboveWater);", 
        "       texelColor = mapTexelToLinear(texelColor);",
        "       diffuseColor *= texelColor;",
        "   #endif",

            //THREE.ShaderChunk["color_fragment"],
        "   #ifdef USE_COLOR",
        "       diffuseColor.rgb *= vColor;",
        "   #endif",

            THREE.ShaderChunk["alphamap_fragment"],
            THREE.ShaderChunk["alphatest_fragment"],
            THREE.ShaderChunk["specularmap_fragment"],
            THREE.ShaderChunk["normal_fragment"],
            THREE.ShaderChunk["emissivemap_fragment"],
        "    reflectedLight.indirectDiffuse = getAmbientLightIrradiance(ambientLightColor);",
            THREE.ShaderChunk["lightmap_fragment"],
        "    reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert(diffuseColor.rgb);",
        "   #ifdef DOUBLE_SIDED",
        "       reflectedLight.directDiffuse = (gl_FrontFacing) ? vLightFront : vLightBack;",
        "   #else",
        "       reflectedLight.directDiffuse = vLightFront;",
        "   #endif",
        "   reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert(diffuseColor.rgb) * getShadowMask();",
            THREE.ShaderChunk["aomap_fragment"],
        "    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;",
            THREE.ShaderChunk["envmap_fragment"],
        "    gl_FragColor = vec4(outgoingLight, diffuseColor.a);",
            THREE.ShaderChunk["tonemapping_fragment"],
            THREE.ShaderChunk["encodings_fragment"],
            THREE.ShaderChunk["fog_fragment"],
            THREE.ShaderChunk["premultiplied_alpha_fragment"],
            THREE.ShaderChunk["dithering_fragment"],
        "}",
    ].join("\n")
};

var shader_phong_terrain = {
    vert: [
        "varying vec3 vViewPosition;",
        "varying float vWaterDepth;",

        "uniform vec2 uvScale;",
        "uniform float waterLevel;",

        "#ifndef FLAT_SHADED",
        "   varying vec3 vNormal;",
        "#endif",
        THREE.ShaderChunk["common"],
        THREE.ShaderChunk["uv_pars_vertex"],
        THREE.ShaderChunk["uv2_pars_vertex"],
        THREE.ShaderChunk["displacementmap_pars_vertex"],
        THREE.ShaderChunk["envmap_pars_vertex"],
        THREE.ShaderChunk["color_pars_vertex"],
        THREE.ShaderChunk["fog_pars_vertex"],
        THREE.ShaderChunk["morphtarget_pars_vertex"],
        THREE.ShaderChunk["skinning_pars_vertex"],
        THREE.ShaderChunk["shadowmap_pars_vertex"],
        THREE.ShaderChunk["logdepthbuf_pars_vertex"],
        THREE.ShaderChunk["clipping_planes_pars_vertex"],
        "void main()",
        "{",
            THREE.ShaderChunk["uv_vertex"],

        "    vUv = uvScale * uv;",
        "    vWaterDepth = waterLevel - position.y;",

            THREE.ShaderChunk["uv2_vertex"],
            THREE.ShaderChunk["color_vertex"],
            THREE.ShaderChunk["beginnormal_vertex"],
            THREE.ShaderChunk["morphnormal_vertex"],
            THREE.ShaderChunk["skinbase_vertex"],
            THREE.ShaderChunk["skinnormal_vertex"],
            THREE.ShaderChunk["defaultnormal_vertex"],
            "#ifndef FLAT_SHADED",
            "   vNormal = normalize(transformedNormal);",
            "#endif",
            THREE.ShaderChunk["begin_vertex"],
            THREE.ShaderChunk["morphtarget_vertex"],
            THREE.ShaderChunk["skinning_vertex"],
            THREE.ShaderChunk["displacementmap_vertex"],
            THREE.ShaderChunk["project_vertex"],
            THREE.ShaderChunk["logdepthbuf_vertex"],
            THREE.ShaderChunk["clipping_planes_vertex"],
            "        vViewPosition = - mvPosition.xyz;",
            THREE.ShaderChunk["worldpos_vertex"],
            THREE.ShaderChunk["envmap_vertex"],
            THREE.ShaderChunk["shadowmap_vertex"],
            THREE.ShaderChunk["fog_vertex"],
        "}",

    ].join("\n"),

    frag: [
        "uniform vec3 diffuse;",
        "uniform vec3 emissive;",
        "uniform vec3 specular;",
        "uniform float shininess;",
        "uniform float opacity;",

        // textures in
        "uniform sampler2D bedTexture;",
        "uniform sampler2D shoreTexture;",
        "uniform sampler2D bedNormal;",
        "uniform sampler2D shoreNormal;",

        "varying float vWaterDepth;",

        THREE.ShaderChunk["common"],
        THREE.ShaderChunk["packing"],
        THREE.ShaderChunk["dithering_pars_fragment"],
        THREE.ShaderChunk["color_pars_fragment"],
        THREE.ShaderChunk["uv_pars_fragment"],
        THREE.ShaderChunk["uv2_pars_fragment"],
        THREE.ShaderChunk["map_pars_fragment"],
        THREE.ShaderChunk["alphamap_pars_fragment"],
        THREE.ShaderChunk["aomap_pars_fragment"],
        THREE.ShaderChunk["lightmap_pars_fragment"],
        THREE.ShaderChunk["emissivemap_pars_fragment"],
        THREE.ShaderChunk["envmap_pars_fragment"],
        THREE.ShaderChunk["gradientmap_pars_fragment"],
        THREE.ShaderChunk["fog_pars_fragment"],
        THREE.ShaderChunk["bsdfs"],
        THREE.ShaderChunk["lights_pars"],
        THREE.ShaderChunk["lights_phong_pars_fragment"],
        THREE.ShaderChunk["shadowmap_pars_fragment"],
        THREE.ShaderChunk["bumpmap_pars_fragment"],
        THREE.ShaderChunk["normalmap_pars_fragment"],
        THREE.ShaderChunk["specularmap_pars_fragment"],
        THREE.ShaderChunk["logdepthbuf_pars_fragment"],
        THREE.ShaderChunk["clipping_planes_pars_fragment"],
        "void main()",
        "{",
            THREE.ShaderChunk["clipping_planes_fragment"],
            "vec4 diffuseColor = vec4(diffuse, opacity);",
            "ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));",
            "vec3 totalEmissiveRadiance = emissive;",
            THREE.ShaderChunk["logdepthbuf_fragment"],

            //THREE.ShaderChunk["map_fragment"],
        "   #ifdef USE_MAP",
        "       float isAboveWater = clamp(-vWaterDepth, 0.0, 1.0);",

        "       vec4 texelColor = mix(texture2D(bedTexture, vUv), texture2D(shoreTexture, vUv), isAboveWater);",
        "       texelColor = mapTexelToLinear(texelColor);",
        "       diffuseColor *= texelColor;",
        "   #endif",

            //THREE.ShaderChunk["color_fragment"],
        "   #ifdef USE_COLOR",
        "       diffuseColor.rgb *= vColor;",
        "   #endif",

            THREE.ShaderChunk["alphamap_fragment"],
            THREE.ShaderChunk["alphatest_fragment"],
            THREE.ShaderChunk["specularmap_fragment"],
            THREE.ShaderChunk["normal_fragment"],
            THREE.ShaderChunk["emissivemap_fragment"],
            THREE.ShaderChunk["lights_phong_fragment"],
            THREE.ShaderChunk["lights_template"],
            THREE.ShaderChunk["aomap_fragment"],
            "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
            THREE.ShaderChunk["envmap_fragment"],
            "gl_FragColor = vec4(outgoingLight, diffuseColor.a);",
            THREE.ShaderChunk["tonemapping_fragment"],
            THREE.ShaderChunk["encodings_fragment"],
            THREE.ShaderChunk["fog_fragment"],
            THREE.ShaderChunk["premultiplied_alpha_fragment"],
            THREE.ShaderChunk["dithering_fragment"],
        "}",

    ].join("\n")
};

var shader_pbr_terrain = {
    vert: [
        "varying vec3 vViewPosition;",
        "varying float vWaterDepth;",

        "uniform vec2 uvScale;",
        "uniform float waterLevel;",

        "#ifndef FLAT_SHADED",
        "   varying vec3 vNormal;",
        "#endif",

        THREE.ShaderChunk["common"],
        THREE.ShaderChunk["uv_pars_vertex"],
        THREE.ShaderChunk["uv2_pars_vertex"],
        THREE.ShaderChunk["displacementmap_pars_vertex"],
        THREE.ShaderChunk["color_pars_vertex"],
        THREE.ShaderChunk["fog_pars_vertex"],
        THREE.ShaderChunk["morphtarget_pars_vertex"],
        THREE.ShaderChunk["skinning_pars_vertex"],
        THREE.ShaderChunk["shadowmap_pars_vertex"],
        THREE.ShaderChunk["logdepthbuf_pars_vertex"],
        THREE.ShaderChunk["clipping_planes_pars_vertex"],
        "void main()",
        "{",
            THREE.ShaderChunk["uv_vertex"],

        "    vUv = uvScale * uv;",
        "    vWaterDepth = waterLevel - position.y;",

            THREE.ShaderChunk["uv2_vertex"],
            THREE.ShaderChunk["color_vertex"],
            THREE.ShaderChunk["beginnormal_vertex"],
            THREE.ShaderChunk["morphnormal_vertex"],
            THREE.ShaderChunk["skinbase_vertex"],
            THREE.ShaderChunk["skinnormal_vertex"],
            THREE.ShaderChunk["defaultnormal_vertex"],
            "#ifndef FLAT_SHADED",
            "   vNormal = normalize(transformedNormal);",
            "#endif",
            THREE.ShaderChunk["begin_vertex"],
            THREE.ShaderChunk["morphtarget_vertex"],
            THREE.ShaderChunk["skinning_vertex"],
            THREE.ShaderChunk["displacementmap_vertex"],
            THREE.ShaderChunk["project_vertex"],
            THREE.ShaderChunk["logdepthbuf_vertex"],
            THREE.ShaderChunk["clipping_planes_vertex"],
            "vViewPosition = - mvPosition.xyz;",
            THREE.ShaderChunk["worldpos_vertex"],
            THREE.ShaderChunk["shadowmap_vertex"],
            THREE.ShaderChunk["fog_vertex"],
        "}",

    ].join("\n"),

    frag: [
        "uniform vec3 diffuse;",
        "uniform vec3 emissive;",
        "uniform float roughness;",
        "uniform float metalness;",
        "uniform float opacity;",
        "#ifndef STANDARD",
        "   uniform float clearCoat;",
        "   uniform float clearCoatRoughness;",
        "#endif",
        "varying vec3 vViewPosition;",
        "#ifndef FLAT_SHADED",
        "   varying vec3 vNormal;",
        "#endif",

        "uniform sampler2D bedTexture;",
        "uniform sampler2D shoreTexture;",
        "uniform sampler2D bedNormal;",
        "uniform sampler2D shoreNormal;",

        "varying float vWaterDepth;",

        THREE.ShaderChunk["common"],
        THREE.ShaderChunk["packing"],
        THREE.ShaderChunk["dithering_pars_fragment"],
        THREE.ShaderChunk["color_pars_fragment"],
        THREE.ShaderChunk["uv_pars_fragment"],
        THREE.ShaderChunk["uv2_pars_fragment"],
        THREE.ShaderChunk["map_pars_fragment"],
        THREE.ShaderChunk["alphamap_pars_fragment"],
        THREE.ShaderChunk["aomap_pars_fragment"],
        THREE.ShaderChunk["lightmap_pars_fragment"],
        THREE.ShaderChunk["emissivemap_pars_fragment"],
        "float reflectivity = 0.0;",
        THREE.ShaderChunk["envmap_pars_fragment"],
        THREE.ShaderChunk["fog_pars_fragment"],
        THREE.ShaderChunk["bsdfs"],
        THREE.ShaderChunk["cube_uv_reflection_fragment"],
        THREE.ShaderChunk["lights_pars"],
        THREE.ShaderChunk["lights_physical_pars_fragment"],

        //THREE.ShaderChunk["shadowmap_pars_fragment"],

        "#ifdef USE_SHADOWMAP",
        "#if NUM_DIR_LIGHTS > 0",
        "		uniform sampler2D directionalShadowMap[NUM_DIR_LIGHTS];",
        "varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHTS];",
        "#endif",
        "#if NUM_SPOT_LIGHTS > 0",
        "		uniform sampler2D spotShadowMap[NUM_SPOT_LIGHTS];",
        "varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHTS];",
        "#endif",
        "#if NUM_POINT_LIGHTS > 0",
        "		uniform sampler2D pointShadowMap[NUM_POINT_LIGHTS];",
        "varying vec4 vPointShadowCoord[NUM_POINT_LIGHTS];",
        "#endif",
        "float texture2DCompare(sampler2D depths, vec2 uv, float compare ) {",
        "    return step(compare, unpackRGBAToDepth(texture2D(depths, uv)));",
        "}",
        "float texture2DShadowLerp(sampler2D depths, vec2 size, vec2 uv, float compare ) {",
        "    const vec2 offset = vec2(0.0, 1.0);",
        "    vec2 texelSize = vec2(1.0) / size;",
        "    vec2 centroidUV = floor(uv * size + 0.5) / size;",
        "    float lb = texture2DCompare(depths, centroidUV + texelSize * offset.xx, compare);",
        "    float lt = texture2DCompare(depths, centroidUV + texelSize * offset.xy, compare);",
        "    float rb = texture2DCompare(depths, centroidUV + texelSize * offset.yx, compare);",
        "    float rt = texture2DCompare(depths, centroidUV + texelSize * offset.yy, compare);",
        "    vec2 f = fract(uv * size + 0.5);",
        "    float a = mix(lb, lt, f.y);",
        "    float b = mix(rb, rt, f.y);",
        "    float c = mix(a, b, f.x);",
        "    return c;",
        "}",
        "float getShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {",
        "    float shadow = 1.0;",
        "    shadowCoord.xyz /= shadowCoord.w;",
        "    shadowCoord.z += shadowBias;",
        "    bvec4 inFrustumVec = bvec4(shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0);",
        "    bool inFrustum = all(inFrustumVec);",
        "    bvec2 frustumTestVec = bvec2(inFrustum, shadowCoord.z <= 1.0);",
        "    bool frustumTest = all(frustumTestVec);",
        "    if (frustumTest) {",
        "        #if defined(SHADOWMAP_TYPE_PCF)",
        "			vec2 texelSize = vec2(1.0) / shadowMapSize;",
        "        float dx0 = - texelSize.x * shadowRadius;",
        "        float dy0 = - texelSize.y * shadowRadius;",
        "        float dx1 = + texelSize.x * shadowRadius;",
        "        float dy1 = + texelSize.y * shadowRadius;",
        "        shadow = (",
        "            texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx0, dy0), shadowCoord.z) +",
        "            texture2DCompare(shadowMap, shadowCoord.xy + vec2(0.0, dy0), shadowCoord.z) +",
        "            texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx1, dy0), shadowCoord.z) +",
        "            texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx0, 0.0), shadowCoord.z) +",
        "            texture2DCompare(shadowMap, shadowCoord.xy, shadowCoord.z) +",
        "            texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx1, 0.0), shadowCoord.z) +",
        "            texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx0, dy1), shadowCoord.z) +",
        "            texture2DCompare(shadowMap, shadowCoord.xy + vec2(0.0, dy1), shadowCoord.z) +",
        "            texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx1, dy1), shadowCoord.z)",
        "        ) * (1.0 / 9.0);",
        "        #elif defined(SHADOWMAP_TYPE_PCF_SOFT)",
        "        vec2 texelSize = vec2(1.0) / shadowMapSize;",
        "        float dx = texelSize.x * shadowRadius;",
        "        float dy = texelSize.y * shadowRadius;",

        "        #define ITERATIONS_START -2",
        "        #define ITERATIONS_END 2",
        "        float sum = 0.0;",
        "        float count = 0.0;",
        // NOTE: Manually unrolling this loop yields a significant performance increase. Looped version remains below commented out.
        // NOTE2: This unrolled loop actually fucks the performance completely on chrome on the win7 machines in the computer lab. needs more testing...
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(-2.0 * dx , -2.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(-2.0 * dx , -1.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(-2.0 * dx , 0), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(-2.0 * dx , 1.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(-2.0 * dx , 2.0 * dy), shadowCoord.z);",

        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(-1.0 * dx , -2.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(-1.0 * dx , -1.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(-1.0 * dx , 0), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(-1.0 * dx , 1.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(-1.0 * dx , 2.0 * dy), shadowCoord.z);",

        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(0 , -2.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(0 , -1.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(0 , 0), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(0 , 1.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(0 , 2.0 * dy), shadowCoord.z);",

        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(1.0 * dx , -2.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(1.0 * dx , -1.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(1.0 * dx , 0), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(1.0 * dx , 1.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(1.0 * dx , 2.0 * dy), shadowCoord.z);",

        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(2.0 * dx , -2.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(2.0 * dx , -1.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(2.0 * dx , 0), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(2.0 * dx , 1.0 * dy), shadowCoord.z);",
        //"        sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(2.0 * dx , 2.0 * dy), shadowCoord.z);",

        //"        count = 25.0;",
        "        for (int y = ITERATIONS_START; y <= ITERATIONS_END; y++)",
        "        {",
        "            for (int x = ITERATIONS_START; x <= ITERATIONS_END; x++)",
        "            {",
        "                vec2 offset = vec2(x, y);",  
        "                sum += texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(offset.x * dx , offset.y * dy), shadowCoord.z);",
        "                count++;",
        "            }",
        "        }",

        "        shadow = sum / count;",
        "        #else",
        "        shadow = texture2DCompare(shadowMap, shadowCoord.xy, shadowCoord.z);",
        "        #endif",
        "    }",
        "    return shadow;",
        "}",
        "vec2 cubeToUV(vec3 v, float texelSizeY ) {",
        "    vec3 absV = abs(v);",
        "    float scaleToCube = 1.0 / max(absV.x, max(absV.y, absV.z));",
        "    absV *= scaleToCube;",
        "    v *= scaleToCube * (1.0 - 2.0 * texelSizeY);",
        "    vec2 planar = v.xy;",
        "    float almostATexel = 1.5 * texelSizeY;",
        "    float almostOne = 1.0 - almostATexel;",
        "    if (absV.z >= almostOne) {",
        "        if (v.z > 0.0)",
        "            planar.x = 4.0 - v.x;",
        "    } else if (absV.x >= almostOne) {",
        "        float signX = sign(v.x);",
        "        planar.x = v.z * signX + 2.0 * signX;",
        "    } else if (absV.y >= almostOne) {",
        "        float signY = sign(v.y);",
        "        planar.x = v.x + 2.0 * signY + 2.0;",
        "        planar.y = v.z * signY - 2.0;",
        "    }",
        "    return vec2(0.125, 0.25) * planar + vec2(0.375, 0.75);",
        "}",
        "float getPointShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {",
        "    vec2 texelSize = vec2(1.0) / (shadowMapSize * vec2(4.0, 2.0));",
        "    vec3 lightToPosition = shadowCoord.xyz;",
        "    float dp = (length(lightToPosition) - shadowCameraNear) / (shadowCameraFar - shadowCameraNear); dp += shadowBias;",
        "    vec3 bd3D = normalize(lightToPosition);",
        "    #if defined(SHADOWMAP_TYPE_PCF) || defined(SHADOWMAP_TYPE_PCF_SOFT)",
        "			vec2 offset = vec2(- 1, 1) * shadowRadius * texelSize.y;",
        "    return (",
        "        texture2DCompare(shadowMap, cubeToUV(bd3D + offset.xyy, texelSize.y), dp) +",
        "        texture2DCompare(shadowMap, cubeToUV(bd3D + offset.yyy, texelSize.y), dp) +",
        "        texture2DCompare(shadowMap, cubeToUV(bd3D + offset.xyx, texelSize.y), dp) +",
        "        texture2DCompare(shadowMap, cubeToUV(bd3D + offset.yyx, texelSize.y), dp) +",
        "        texture2DCompare(shadowMap, cubeToUV(bd3D, texelSize.y), dp) +",
        "        texture2DCompare(shadowMap, cubeToUV(bd3D + offset.xxy, texelSize.y), dp) +",
        "        texture2DCompare(shadowMap, cubeToUV(bd3D + offset.yxy, texelSize.y), dp) +",
        "        texture2DCompare(shadowMap, cubeToUV(bd3D + offset.xxx, texelSize.y), dp) +",
        "        texture2DCompare(shadowMap, cubeToUV(bd3D + offset.yxx, texelSize.y), dp)",
        "    ) * (1.0 / 9.0);",
        "    #else",
        "    return texture2DCompare(shadowMap, cubeToUV(bd3D, texelSize.y), dp);",
        "    #endif",
        "}",
        "#endif",


        THREE.ShaderChunk["bumpmap_pars_fragment"],

        //THREE.ShaderChunk["normalmap_pars_fragment"], with function unrolled and placed in main body
        "uniform sampler2D normalMap;",
        "uniform vec2 normalScale;",

        THREE.ShaderChunk["roughnessmap_pars_fragment"],
        THREE.ShaderChunk["metalnessmap_pars_fragment"],
        THREE.ShaderChunk["logdepthbuf_pars_fragment"],
        THREE.ShaderChunk["clipping_planes_pars_fragment"],
        "void main()",
        "{",
            THREE.ShaderChunk["clipping_planes_fragment"],
            "vec4 diffuseColor = vec4(diffuse, opacity);",
            "ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));",
            "vec3 totalEmissiveRadiance = emissive;",
            THREE.ShaderChunk["logdepthbuf_fragment"],

            //THREE.ShaderChunk["map_fragment"],
            "   #ifdef USE_MAP",
            "       float isAboveWater = clamp(-vWaterDepth, 0.0, 1.0);",
            "       vec4 texelColor = mix(texture2D(bedTexture, vUv), texture2D(shoreTexture, vUv), isAboveWater);",
            "       texelColor = mapTexelToLinear(texelColor);",
            "       diffuseColor *= texelColor;",
            "   #endif",

            THREE.ShaderChunk["color_fragment"],
            THREE.ShaderChunk["alphamap_fragment"],
            THREE.ShaderChunk["alphatest_fragment"],
            THREE.ShaderChunk["roughnessmap_fragment"],
            THREE.ShaderChunk["metalnessmap_fragment"],

            //THREE.ShaderChunk["normal_fragment"],
            "#ifdef FLAT_SHADED",
                "vec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));",
                "vec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));",
                "vec3 normal = normalize(cross(fdx, fdy));",
                "#else",
                "vec3 normal = normalize(vNormal);",

                "#ifdef DOUBLE_SIDED",
                    "normal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);",
                "#endif",
            "#endif",

            // Normalmap perturbNormal2Arb() function unrolled for debugging.

            "#ifdef USE_NORMALMAP",
                "vec3 eye_pos = -vViewPosition;",
                "vec3 surf_norm = normal;",

                "vec3 q0 = vec3(dFdx(eye_pos.x), dFdx(eye_pos.y), dFdx(eye_pos.z));",
                "vec3 q1 = vec3(dFdy(eye_pos.x), dFdy(eye_pos.y), dFdy(eye_pos.z));",
                "vec2 st0 = dFdx(vUv.st);",
                "vec2 st1 = dFdy(vUv.st);",
                "vec3 S = normalize(q0 * st1.t - q1 * st0.t);",
                "vec3 T = normalize(-q0 * st1.s + q1 * st0.s);",
                "vec3 N = normalize(surf_norm);",

                "vec3 mapN = mix(texture2D(bedNormal, vUv), texture2D(shoreNormal, vUv), isAboveWater).xyz * 2.0 - 1.0;",
                //"vec3 mapN = texture2D(bedNormal, vUv).xyz * 2.0 - 1.0;",
                "mapN.xy = normalScale * mapN.xy;",
                "mat3 tsn = mat3(S, T, N);",
                "normal = tsn * mapN;",
    
                //"gl_FragColor = vec4(normal, 1);",
            "#endif",
            THREE.ShaderChunk["emissivemap_fragment"],
            //THREE.ShaderChunk["lights_physical_fragment"],

            "PhysicalMaterial material;",
            "material.diffuseColor = diffuseColor.rgb;",

            THREE.ShaderChunk["lights_template"],
            THREE.ShaderChunk["aomap_fragment"],
            "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
            "gl_FragColor = vec4(outgoingLight, diffuseColor.a);",

            THREE.ShaderChunk["tonemapping_fragment"],
            THREE.ShaderChunk["encodings_fragment"],
            THREE.ShaderChunk["fog_fragment"],
            THREE.ShaderChunk["premultiplied_alpha_fragment"],
            THREE.ShaderChunk["dithering_fragment"],
        "}",

    ].join("\n")
};